#include "hal.h"
#include "hal_map_p.h"
#include "kal.h"
#include "rac.h"
#include "d7.h"

#if 1
#define DPRINT(...)      hal_dbg_print(__VA_ARGS__)
#else
#define DPRINT(...)
#endif

typedef struct {
    rac_rx_cfg_t rx_cfg;
    rac_tx_cfg_t tx_cfg;
} ctx_t;

ctx_t g_ctx;
u8 BPM = 114;
u16 timeToBroadcastInMS;
u16 nextMeasure;
u16 measureNum = 0;
u16 nextMeasureHighHat[119] = {0x0000, 0x0000, 0x0000, 0x0000, 0x2AAA, 0xAAAA, 0xAAAA, 0xAAAA, 0x2AAA, 0xAAAA, 0xAAAA, 0xAAAA, 0x2AAA, 0xAAAA, 0xAAAA, 0xAAAA, 0x2AAA, 0xAAAA, 0xAAAA, 0xAAA0, 0x2AAA, 0xAAAB, 0xAAAA, 0xAAAA, 0xAAAB, 0xAAAA, 0xAAAB, 0xAAA8, 0x2AAA, 0xAAAB, 0xAAAA, 0xAAAA, 0xAAAB, 0xAAAA, 0xAAAB, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0xAAAA, 0xAA80, 0x0000, 0x0000, 0x2AAA, 0xAAAB, 0xAAAA, 0xAAAA, 0xAAAB, 0xAAAA, 0xAAAB, 0xAAA8, 0x2AAA, 0xAAAB, 0xAAAA, 0xAAAA, 0xAAAB, 0xAAAA, 0xAAAB, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2AAA, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0xAAAA, 0x2AAA, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002, 0xAAAA, 0xAA80, 0x0000, 0x0000};
u16 nextMeasureSnare[119] = {0x0000, 0x0000, 0x0000, 0x00FA, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x8208, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x082A, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0xAA88, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x082A, 0x0800, 0x0008, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x082A, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0xAA88, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0800, 0x0008, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0002, 0xAAA8, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0xAA88, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x0808, 0x082A, 0x0800, 0x0008};
u16 nextMeasureRide[119] = {0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x8888, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x8888, 0x0000, 0x0000, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x8888, 0x0888, 0x8888, 0x0000, 0x0000, 0x0000, 0x0000};
u16 nextMeasureKickDrum[119] = {0x0000, 0x0000, 0x0000, 0x0000, 0x8082, 0x8080, 0x8080, 0x8080, 0x8082, 0x8080, 0x8080, 0x8080, 0x8082, 0x8080, 0x8080, 0x8080, 0x8082, 0x8080, 0x8080, 0x28A0, 0x8080, 0x8080, 0x8080, 0x80A0, 0x8080, 0x8080, 0x8080, 0x80A0, 0x8080, 0x8080, 0x8080, 0x80A0, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x0000, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8082, 0x8080, 0x8208, 0x0030, 0x8080, 0x8080, 0x8080, 0x80A0, 0x8080, 0x8080, 0x8080, 0x80A0, 0x8080, 0x8080, 0x8080, 0x80A0, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x0000, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8208, 0x0030, 0x8202, 0x80A0, 0x8202, 0x80A0, 0x8202, 0x80A0, 0x8220, 0x8888, 0x8888, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x0000, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8280, 0x8082, 0x8080, 0x8208, 0x0030
};

KAL_PROCESS(master_p, USER_PID(0));

KAL_PROC_THREAD(master_p, ev, evp)
{
    u8 clock_tim;

    rac_rx_res_t* pkt;
    static fg_t fg;
    u8 wbuf[32]; // XXX
    u8 cmd[9];

    KAL_PROC_EXITHANDLER(
        kal_timer_stop(clock_tim);
        clock_tim = KAL_NO_TIMER;
        KAL_PROC_EXIT();
    )
    
    pkt = (rac_rx_res_t*)evp.msg;
    KAL_PROC_BEGIN();
    g_ctx.rx_cfg         = RX_CONTINUOUS_CFG;
    // start Rx
    timeToBroadcastInMS = 60.0/BPM * 1000;;
            		    //DPRINT("%d\n", timeToBroadcastInMS);
    
    rac_rx_start(&g_ctx.rx_cfg);

    while (1)
    {
        KAL_PROC_WAIT_EVENT();
        if ((ev==HAL_EVT_BUTTON1)||(ev==HAL_EVT_BUTTON2)||(ev==HAL_EVT_BUTTON3))
        {
            rac_idle();
            if (ev==HAL_EVT_BUTTON2)
            {   // Start
                cmd[0] = 0x00;
                fg.len = 1;
		DPRINT("START\n");
				clock_tim = kal_timer_start(KAL_ETIMER,
					&master_p, 0, timeToBroadcastInMS);
		DPRINT("%d", clock_tim);
            }
            else if (ev==HAL_EVT_BUTTON3)
            {	// Initialization broadcast.
                cmd[0] = 0x01;
                cmd[1] = 0x3C; //BPM
		DPRINT("BPM\n");
				fg.len = 2;
            }
			else
			{	//Measure broadcast., will use timer as event, instead of button when array is set up.
				cmd[0] = 0x02;
				cmd[1] = 0x80; //First half
				cmd[2] = 0x00;//Second half
				fg.len = 3;
				DPRINT("FIRST MEASURE\n");
			}

            // Send FG frame with auto BG flooding
            fg.fctrl = D7_FFC_EN_ADDR;
            fg.actrl = D7_ACH_ADDR_OPT(ADDR_OPT_BROADCAST);
            fg.data= cmd;
            hal_led_on(HAL_LED_YELLOW);
            g_ctx.tx_cfg        = TX_DEFAULT_CFG;
            g_ctx.tx_cfg.len    = d7_build_fg(wbuf,&fg);
            g_ctx.tx_cfg.data   = wbuf;
            g_ctx.tx_cfg.mode   = RAC_TX_FG_WITH_BG_ADVP;
            g_ctx.tx_cfg.start  = rac_gettime() + (u32)BG_ADV_TIME;
            rac_tx_start(&g_ctx.tx_cfg);

            KAL_PROC_WAIT_EVENT_UNTIL(ev == RAC_EVT_TX_DONE);
            hal_led_off(HAL_LED_YELLOW);

            // Restart Rx
            rac_rx_start(&g_ctx.rx_cfg);
        }
		else if(ev == KAL_EVT_TIMER){
			//The timer will determine when each new measure is sent,  This should be based off of BPM
			rac_idle();
            		 //   DPRINT("%d\n", timeToBroadcastInMS);
			//This is where the code to determine which measure should be broadcasted.
			//In this packet, the opcode should be 0x03, to imply a measure and start.  The main controller wizzi will upload the first
			//measure with button1. then start on button 2.  Each time a new measure is sent after the first, it should force each peice to
			//start the new measure, in case of delays or anything.
			
			
			
			//Determine next measure, and set the nextMeasure Array
			//nextMeasureHighHat = measureArrayHighHat[i];
			//THIS WILL NEED ADAPTED FOR SENDING EVERY DEVICE PACKET
			
			
			//Set up packet, Should end up with 15 bytes per measure packets.
			//High hat is 1, 2 bytes
			//Ride is 3, 4
			//KickDrum is 5, 6


			if(measureNum < 119){
				cmd[0] = 0x03;
				cmd[1] = nextMeasureHighHat[measureNum] >> 8; //First half of measure
				cmd[2] = nextMeasureHighHat[measureNum]; //Second half of measure
				cmd[3] = nextMeasureRide[measureNum] >> 8;
				cmd[4] = nextMeasureRide[measureNum];
				cmd[5] = nextMeasureKickDrum[measureNum] >> 8;
				cmd[6] = nextMeasureKickDrum[measureNum];
				cmd[7] = nextMeasureSnare[measureNum] >> 8;
				cmd[8] = nextMeasureSnare[measureNum];

				fg.len = 9;


			    // Send FG frame with auto BG flooding
			    fg.fctrl = D7_FFC_EN_ADDR;
			    fg.actrl = D7_ACH_ADDR_OPT(ADDR_OPT_BROADCAST);
			    fg.data= cmd;
			    hal_led_on(HAL_LED_YELLOW);
			    g_ctx.tx_cfg        = TX_DEFAULT_CFG;
			    g_ctx.tx_cfg.len    = d7_build_fg(wbuf,&fg);
			    g_ctx.tx_cfg.data   = wbuf;
			    g_ctx.tx_cfg.mode   = RAC_TX_FG_WITH_BG_ADVP;
			    g_ctx.tx_cfg.start  = rac_gettime() + (u32)BG_ADV_TIME;
			    rac_tx_start(&g_ctx.tx_cfg);

			    KAL_PROC_WAIT_EVENT_UNTIL(ev == RAC_EVT_TX_DONE);
			    hal_led_off(HAL_LED_YELLOW);

			    // Restart Rx
			    rac_rx_start(&g_ctx.rx_cfg);
			
			clock_tim = kal_timer_start(KAL_ETIMER,
				&master_p, 0, timeToBroadcastInMS);
			    measureNum = measureNum + 1;
			}
		}
	    else
	    {
			DPRINT("Unknown CMD:%#x\n",fg.data[0]);
	    }
	    kal_free(pkt);
    }
    KAL_PROC_END();
}

void main(void) {

    // Open HAL layer    
    hal_open();
    // Open KAL layer
    kal_open();
    // Initialize buttons
	hal_button_open(&master_p);
    // Initialize Serial
    hal_serial_open(HAL_SERIAL_MODE_PACKET, HAL_SERIAL_BAUDRATE_115200,NULL);

    DPRINT("Sensor Master Test ("__DATE__ " " __TIME__ ")\n");

    hal_led_off(HAL_LED_RED|HAL_LED_YELLOW|HAL_LED_GREEN);

    // Start processes
    rac_open(&master_p);
    kal_proc_start(&master_p, (evt_param_t)NULL);

    // Run scheduler
    kal_proc_schedule();
}

